n,m=map(int, input().split())

board = list() # 모든 체스판 입력 받기

result=[]

for i in range(n):
    board.append(input())

# 입력받은 체스판의 크기마다 , 8*8이 움직여야 한다.
# 각각 움직이면서 필요한 W,B의 갯수를 구하고, 각각의 움직임에서 얻어진 최소 개수를 구한다.

for i in range(n-7): # 가로 (n -7)번 이동 필요
    for j in range(m-7): # 세로 (m-7)번 이동 필요

        # 체스판을 각각 이동하면서 좌측 최상단에 흰색, 검은색 2가지의 경우에 대해서 색칠해야 하는 개수를 기록한다.

        count_W = 0 # 좌측, 최상단이 W로 와야할 경우 , 우리가 색칠할 체스판의 개수
        count_B = 0 # 좌측, 최상단이 B로 와야할 경우 , 우리가 색칠할 체스판의 개수

        for k in range(i,i+8): # 8*8 고정된 크기에서 이동 필요
            for l in range(j,j+8):
                if (k+l) %2 == 0: # 현재 행의 번호 i, 현재 열의 번호 j의 합이 짝수이면 시작점의 색깔과 같아야 하고, 홀수이면 시작점의 색깔과 다른 색이어야 한다.
                    
                    # 체스판을 하나씩 읽어들이는데, 2가지의 경우에 대해서 한번에 계산한다.
                    
                    # 짝수일 경우, 흰색 W가 오도록 가정
                    if board[k][l] != 'W':
                        count_W += 1
                    # 짝수일 경우, 검은색 B가 오도록 가정 , 만약 위에서 W가 처음에 들어왔는데 (좌측, 최상단이 B로 와야할 경우)에 대해서는 색칠이 필요한 부분이기 때문에 +1를 해준다.
                    if board[k][l] != 'B':
                        count_B += 1    

                else:
                    # 만약 홀수라면, 시작점의 색깔과 달라야 한다.

                    # 체스판을 하나씩 읽어들이는데, 2가지의 경우에 대해서 한번에 계산한다.

                    # 위와는 반대로 홀수일 경우에는 검은색 B가 오도록 가정 -> 그말은 좌측 최상단이 W으로 시작했다는 의미
                    if board[k][l] != 'B':
                        count_W += 1 # 여기서 W +=1 이라는 의미는 W로 색칠을 하겠다는게 아니라, 첫시작이 W로 시작한 체스판에 1번 더 어떤 색깔(B)을 칠해야 한다는 의미이다. 
                    # 위와는 반대로 홀수일 경우에는 흰색 W가 오도록 가정 -> 그말은 좌측 최상단이 B로 시작했다는 의미
                    if board[k][l] != 'W':
                        count_B +=1
        
        result.append(min(count_W,count_B)) # 8*8이 한자리에 있었을때, 좌측 최상단이 W로 시작 혹은 B로 시작하는 경우에 따라서 최소의 색칠 갯수를 구한다.

# 모든 판을 다 돌면서 최소의 색칠 갯수를 구한다.
print(min(result))






